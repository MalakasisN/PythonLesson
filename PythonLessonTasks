SET 1:

### Άσκηση 1
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παράμετρους. Θα επιστρέφει το άθροισμά τους. Η συνάρτηση πρέπει να ελέγχει αν η είσοδος είναι int ή float. Αν η είσοδος δεν είναι int ή float θα τυπώνει ένα μήνυμα λάθους.

### Άσκηση 2
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παραμέτρους. Θα επιστρέφει τους αριθμούς αυτούς ταξινομημένους από τον μικρότερο στον μεγαλύτερο. Μην χρησιμοποιήσετε min. Επίσης η συνάρτηση θα ελέγχει αν οι παράμετροι είναι int ή float. Αν κάποια παράμετρος δεν είναι int ή float, θα τυπώνει μήνυμα λάθους

### Άσκηση 3
Φτιάξτε μία συνάρτηση η οποία θα παίρνει τρεις παραμέτρους. Θα επιστρέφει το ζευγάρι αριθμών που έχει τη μικρότερη απόσταση. Ως απόσταση ορίζεται το απόλυτο της διαφοράς τους. Για παράδειγμα: οι 2 αριθμοί που έχουν την μικρότερη απόσταση από τους 1,7,3 είναι το 1 και το 3. Όπως και στις ασκήσεις 1 και 2 θα πρέπει να ελέγχει ότι οι αριθμοί είναι int ή float.

### Άσκηση 4
Φτιάξτε μία συνάρτηση η οποία θα παίρνει ως είσοδο μία ακολουθεία νουκλεοτιδίων. Π.χ. μία είσοδος είναι η 'AAACGTTCGGAA'. Η συνάρτηση θα πρέπει να επιστρέφει True αν η ακολουθεία ΔΕΝ περιέχει άλλο γράμμα πέρα από τα 'A', 'C', 'G', 'T'. Για παράδειγμα αν η είσοδος είναι 'ACCGGFT', τότε επιστρέφει False. Αν η ακολουθεία είναι η 'ACCCAA', τότε επιστρέφει True. Αν η ακολουθεία είναι κενή τότε πρέπει να επιστρέφει False.

### Άσκηση 5
Το ίδιο με την Άσκηση 4 αλλά θα πρέπει να ελέγχει και αν το μήκος της ακολουθίας διαιρείται με το 3. Για παράδειγμα:
```
ACCCTA --> True
ACCFTT --> False (Δεν είναι όλα τα γράμματα A,C,G,T)
ACCCT  --> False (Δεν διαιρείται με το 3 το μήκος της)
ACCCF  --> False (Δεν διαιρείται με το 3 το μήκος της και έχει ένα γράμμα που δεν είναι A,C,G,T)
```

### Άσκηση 6
Από όλα τα ζευγάρια ακέραιων αριθμών α,β όπου 0<=α<=100 και 0<=β<=100 ποιοι είναι αυτοί για τους οποίους ισχύει:
```
(α+β)^2 = α*10 + β
```

### Άσκηση 7
Γράψτε μία συνάρτηση η οποία θα παίρνει ένα αλφαριθμητικό (string), και θα επιστρέφει έναν ακέραιο που θα αποτελείται από όλα τα ψηφία του αλφαριθμητικού. Για παράδειγμα:
```
"καλη2μέ3ρα" --> 23
"1Ηρά3κλειο9" --> 139
```

### Άσκηση 8
Γράψτε μία συνάρτηση η οποία θα παίρνει 3 αριθμούς από 1 μέχρι το 10. Αρχικά θα ελέγχει αν και οι τρεις είναι διαφορετικοί μεταξύ τους. Αν δεν είναι, θα πετάει ένα μήνυμα λάθους και θα επιστρέφει None. Επίσης θα ελέγχει αν και οι τρεις είναι από το 1 μέχρι το 10 αλλιώς πάλι θα πετάει μήνυμα λάθους. Στη συνέχεια θα επιστρέφει ένα string με μέγεθος 10. Το string αυτό θα έχει τον χαρακτήρα αστεράκι (\*) σε όλες τις θέσεις εκτός από τις θέσεις με αριθμό κάποιον από τα ορίσματα. Σε αυτή τη θέση θα έχει τον αντίστοιχο αριθμό. Παραδείγματα:
```
5,1,9 --> '1***5***9*'
0,1,9 --> ΛΑΘΟΣ, ΟΛΟΙ ΟΙ ΑΡΙΘΜΟΙ ΠΡΕΠΕΙ ΝΑ ΕΙΝΑΙ ΑΠΟ ΤΟ 1 ΜΕΧΡΙ ΤΟ 10
5,1,5 --> ΛΑΘΟΣ, ΟΛΟΙ ΟΙ ΑΡΙΘΜΟΙ ΠΡΕΠΕΙ ΝΑ ΕΙΝΑΙ ΔΙΑΦΟΡΕΤΙΚΟΙ ΜΕΤΑΞΥ ΤΟΥΣ
5,6,8 --> '****56*8**'
```

### Άσκηση 9
Γράψτε μία συνάρτηση η οποία θα παίρνει ένα ακέραιο αριθμό. Αν ο αριθμός είναι μικρότερος από το 100 θα επιστρέφει None και θα τυπώνει ένα μήνυμα λάθους. Διαφορετικά θα επιστρέφει True αν το άθροισμα των δύο πρώτων ψηφίων του είναι άρτιος (ζυγός) ή False αν δεν είναι. Παραδείγματα:
```
48973 --> True (4+8=12, άρτιος)
381 --> False (3+8=11, μονός)
3 --> ΛΑΘΟΣ, Ο ΑΡΙΘΜΟΣ ΠΡΕΠΕΙ ΝΑ ΕΙΝΑΙ ΜΕΓΑΛΥΤΕΡΟΣ ΑΠΟ ΤΟ 100
```

### Άσκηση 10
Μία μέρα έχει 24 ώρες. Μία ώρα έχει 60 λεπτά. Άρα μία μέρα έχει 24\*60=1440 λεπτά. Φτιάξτε μία συνάρτηση που να παίρνει σαν είσοδο έναν αριθμό από το 0 μέχρι και το 1440. Θα πρέπει να επιστρέφει δύο αριθμούς. Ο πρώτος θα είναι η γωνία του ωροδείκτη και ο δεύτερος η γωνία του λεπτοδείκτη, όταν έχουν περάσει τόσα λεπτά από τις 00:00 αυτής της μέρας, όσα η παράμετρος της συνάρτησης. Κάθε γωνία πρέπει να είναι ένας αριθμός από το 0 μέχρι το 360. 0 μοίρες είναι όταν ένας δείκτης είναι στο "12" του ρολογιού, 90 μοίρες είναι όταν είναι στο "3", 180 μοίρες είναι όταν ο δείκτης είναι στο "6" του ρολογιού, 270 μοίρες είναι όταν είναι στο 9. Μερικά παραδείγματα:
```
ΛΕΠΤΑ --> ΩΡΟΔΕΙΚΤΗΣ, ΛΕΠΤΟΔΕΙΚΤΗΣ
0 --> 0.0, 0.0
5 --> 2.5, 30.0
180 --> 90.0, 0.0
681 --> 340.5, 126.0
1000 --> 140.0, 240.0
```

### Άσκηση 11
Αν μία μπάλα χάνει το 7% του ύψους της κάθε φορά που αναπηδάει και την αφήσουμε να πέσει από το 1 μέτρο, μετά από πόσες αναπηδήσεις θα έχει φτάσει σε ύψος κάτω από το μισό μέτρο; Φτάξτε κώδικα python που απαντάει σε αυτό το ερώτημα με επαναληπτικό τρόπο (αν θέλετε κάντε το και με αναλυτικό). 

### Άσκηση 12
Βρείτε όλες τις λύσεις της εξίσωσης: ``` x^2 = y! + 1 ``` για 1<=x<=100 και 1<=y<=100. Όπου x και y είναι ακέραιοι.

### Άσκηση 13
Υπάρχουν μερικοί αριθμοί που μπορούν να γραφούν σαν άθροισμα δύο κύβων. Για παράδειγμα το 468 μπορεί να γραφεί σαν 5^3 + 7^3. Υπάρχει όμως μόνο δύο αριθμοί μικρότεροι από το 10.000, οι οποίοι μπορούν να γραφτούν με δύο τρόπους σαν άθροισμα δύο κύβων! Ο ένας από αυτούς είναι το 1729 επειδή: ``` 1729 = 1^3 + 12^3 και 1729 = 9^3 + 10^3 ```. Ποιος είναι ο δεύτερος αριθμός που έχει αυτή την ιδιότητα; Σημείωση: ψάχνουμε μόνο αριθμούς < 10.000 .

### Άσκηση 14
Ας υποθέσουμε ότι έχουμε ένα string (αλφαριθμητικό) το οποίο αποτελείται μόνο από '+' και '-'. Για παράδειγμα ```+----+++--```. Υποθέτουμε ότι το '+' αναπαριστά ένα πρωτόνιο και το '-' ένα αντι-πρωτόνιο! Όταν ένα πρωτόνιο ('+') και ένα αντι-πρωτόνιο ('-') είναι δίπλα-δίπλα τότε αυτά εξαφανίζονται! Για παράδειγμα παρακάτω έχω σημείωσει τις θέσεις όπου υπάρχουν '+' και '-' δίπλα-δίπλα (τις σημείωνω με ^).
```
+----+++--
^^  ^^ ^^
``` 

Αν εξαφανίσουμε λοιπόν τις θέσεις που τα + και - είναι δίπλα-δίπλα, το string θα γίνει:
```
--+-
```

Και πάλι όμως βλέπουμε ότι το νέο string έχει '+' και '-' δίπλα-δίπλα. Οπότε αυτές οι θέσεις θα εξαφανιστούν και θα γίνει:
```
--
```

Τώρα παρατηρούμε ότι αφού έχει μόνο '-', το string δεν μπορεί να μικρύνει άλλο.

Φτιάξτε μία συνάρτηση που να παίρνει ένα string και θα ελέγχει αν έχει μόνο + και -. Στη συνέχεια πρέπει να επιστρέφει το string το οποίο ΔΕΝ μπορεί να μικρύνει άλλο. Δίνονται μερικά παραδείγματα:

```
+++---++-++--+--++-----++++-++-+++++--++-+---+----++++-+-++----+--+++-++--+-+-+++--+++--+++++++-+-++    ==>   ++++++++++++
+-+---++------+++-++++-+-+--+--+++--------++++--++---+----+---+++---++--++-++-+-++--+-+-++--++-+++--    ==>   --------
+--+--+++---+----+++--+-+--+--+-+----+++-++--+--+--+++++-+--+-+----++--+++-----+++-+++-++-+-++-++-+-    ==>   ----
```

### Άσκηση 15
Γράψτε μία συνάρτηση η οποία θα παίρνει δύο ακέραιους ως παράμετρους. Ο πρώτος μπορεί να πάρει τιμές από το 1 μέχρι το 31 και αναπαριστά τη μέρα του μήνα. Ο δεύτερος μπορεί να πάρει τιμές από 1 μέχρι το 12 και αναπαριστά τον μήνα του χρόνου (1=Ιανουάριος, 2=Φεβρουάριους, ... 12=Δεκέμβριους). Η συνάρτηση θα πρέπει να επιστρέφει True, αν είναι δυνατός αυτός ο συνδοιασμός (μέρα, μήνα), διαφορετικά θα επιστρέφει False. Σημείωση: υποθέτουμε ότι το έτος ΔΕΝ είναι δίσεκτο. Παραδείγματα:
```
31,1 --> True (31 December)
29,2 --> False (29 February)
32,3 --> Error, invalid range! (32 March)
30,4 --> False (30 April)
31,5 --> True (31 May)
```

### Άσκηση 16
Γράψτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρους τρία strings. Στη συνέχεια θα πρέπει να τα τυπώνει justified. Δηλαδή το κάθε string θα τυπώνεται σε μία ξεχωριστή γραμμή. Όλες οι γραμμές θα έχουν το ίδιο κέντρο. Μπορείτε να υπάρχει διαφορά στην αντιστοίχιση +/- ένα space όπου δεν είναι δυνατό το τέλεια "κεντράρισμα". Για παράδειγμα:
```
python, is, great -->

python
  is
 great
```

```
Μία, ξεχωριστή, μέρα -->

   Μία   
ξεχωριστή
  μέρα
```

### Άσκηση 17
Γράψτε ένα πρόγραμμα το οποία θα παίρνει δύο αριθμούς. Το πρόγραμμα θα επιστρέφει σε πιο τεταρτημόριο του καρτεσιανού διδιάστατου χώρου βρίσκεται το σημείο που ορίζεται από αυτούς τους δύο αριθμούς. Θεωρούμε ότι το κέντρο του χώρου είναι το 0,0. Για παράδειγμα:
```
3,4 --> Πρώτο τεταρτημόριο
-2,7 --> Δεύτερο τερτημόριο
-5,-2 --> Τρίτο τεταρτημόριο
4,-3 --> Τέταρτο τεταρτημόριο
0,0 --> κέντρο
0,1 --> πάνω στον άξονα Υ
3,0 --> πάνω στον άξονά Χ
```

### Άσκηση 18
Ας θεωρήσουμε ένα παράλληλόγραμμα πάτωμα το οποίο είναι στρωμένο με Α x B πλακάκια. Ένα ποντίκι ξεκινάει από το πλακάκι που είναι στην αριστερή κάτω γωνία (π.χ. στη θέση 1,1) και συνεχίζει να περπατάει διαγώνια. Δηλαδή η επόμενή του θέση είναι η (2,2) , μετά (3,3) κτλ. Όταν φτάσει στην άκρη του παραλληλεπίπεδου, τότε συνεχίζει να πηγαίνει διαγώνια όπως ακριβώς μία μπάλα αναπηδάει (ή η μπάλα στο παιχνίδι arkanoid, για όσους το ξέρουν). Το ποντίκι σταματάει όταν φτάσει σε μία από τις τέσσερις γωνίες. Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο θετικούς ακέραιους Α και Β. Στη συνέχεια θα τυπώνει τη πορεία του ποντικιού στο παραλληλελεπίπεδο μέχρι να φτάσει σε μία γωνία. Για παράδειγμα, έστω ότι Α=3 και Β=4. Σημειώνουμε με Χ τη θέση του ποντικιού:
```
Ξεκινάμε πάντα από τη Θέση: 1,1

X** 
***
***
***
``` 

```
επόμενη Θέση: 2,2
***
*Χ*
***
***
``` 

```
επόμενη Θέση: 3,3
***
***
**Χ
***
```

```
επόμενη Θέση: 4,2
***
***
***
*Χ*
``` 

```
επόμενη Θέση: 3,1
***
***
Χ**
***
``` 

```
επόμενη Θέση: 2,2
***
*Χ*
***
***
``` 

```
επόμενη Θέση: 1,3
**Χ
***
***
***
``` 

Οπότε θα πρέπει να τυπώσει:
```
1,1
2,2
3,3
4,2
3,1
2,2
1,3
```


### Άσκηση 19
Εδώ βλέπετε μία μαθηματική φόρμουλα για τον υπολογισμό του π. 
![img](https://pbs.twimg.com/media/D_Hq5UlWwAQ7CfL?format=jpg&name=large) 

Φτιάξτε μία συνάρτηση η οποία να παίρνει έναν ακέραιο αριθμό μεγαλύτερο ή ίσο με το 1. Στη συνέχεια θα επιστρέφει την προσέγγιση του π μέσω της παραπάνω φόρμουλας χρησιμοποιώντας τόσους παράγοντες όσους και η τιμή της παραμέτρου της συνάρτησης. Για παράδειγμα:
```
1 --> 2 
2 --> 2.82842712474619  (2 *  2/sqrt(2) )
3 --> 3.061467458920718 (2 *  2/sqrt(2) * 2/(sqrt(2+sqrt(2))) )
```

Υπολογισμός της τετραγωνικής ρίζας:
```python
import math

math.sqrt(16) # Τυπώνει 4
```

Σημείωση: Η φόρμουλα ανακαλύφτηκε από τον François Viète τον 16ο αιώνα.


### Άσκηση 20 (εξαιρετικά δύσκολη..)
Ένας αριθμός είναι πρώτος όταν διαρείται μόνο με το 1 και με τον εαυτό του. Υπάρχει μόνο ένας πρώτος αριθμός ο οποίος να είναι από το 10.000.000 μέχρι το 100.000.000 ο οποίος να έχει τη παρακάτω περίεργη ιδιότητα: Αν του "κόψεις" έναν οποιοδήποτε αριθμό από ψηφία από τα τέλος, αυτό που μένει να είναι πάντα πρώτος! Ποιος αριθμός είναι αυτός; Για παράδειγμα έστω ότι ο αριθμός που ψάχνουμε είναι ο 12.345.678 (spoiler alert, δεν είναι αυτός). Τότε θα πρέπει όλοι οι παρακάτω αριθμοί να είναι επίσης πρώτοι:
```
12345678
1234567
123456
12345
1234
123
12
1
```

SET 2

### Άσκηση 1
**Η χρήση list comprehension είναι υποχρεωτική**

Ποιο είναι το άθροισμα της τετραγωνικής ρίζας όλων των αριθμών από το 1 μέχρι το 3000 που διαιρούνται με το 3 αλλά όχι με το 6;

Η τετραγωνική ρίζα υπολογίζεται ως εξής:
```
import math
math.sqrt(16)
```

### Άσκηση 2
**Η χρήση list comprehension είναι προτεινόμενη**

Όλα τα ζευγάρια κ,λ θετικών ακεραίων που είναι μικρότεροι ή ίσοι με το 10 όπου το λ διαιρεί ακριβώς το κ είναι:
```
(4, 2), (6, 2), (6, 3), (8, 2), (8, 4), (9, 3), (10, 2), (10, 5)
```

Το άθροισμα των διαφορών αυτώ των ζευγαριών είναι:
```
(4 - 2) + (6 - 2) + (6 - 3) + (8 - 2) + (8 - 4) + (9 - 3) + (10 - 2) + (10 - 5) = 38
```

Ποιο είναι το αντίστοιχο άθροισμα διαφορών αν πάρουμε όλα τα ζευγάρια κ,λ που είναι μικρότεροι η ίσοι με το 1000;

### Άσκηση 3
Φτιάξτε μία συνάρτηση με το όνομα f η οποία να επιστρέφει μία συνάρτηση η οποία να επιτρέφει μία συνάρτηση η οποία να επιστρέφει μία λίστα της οποίας το 2ο στοιχείο να είναι μία συνάρτηση η οποία να επιστρέφει το string 'mitsos'. Θα πρέπει δηλαδή να μπορώ να κάνω:

```python
f()()()[1]()

#Αυτό πρέπει να Τυπώνει: 'Μήτσος'
```

### Άσκηση 4
Φτιάξτε μία συνάρτηση με τον όνομα f η οποία να επιστρέφει μία λίστα με 10 στοιχεία. 

Το πρώτο στοιχείο της λίστας θα είναι μία συνάρτηση η οποία θα παίρνει σαν όρισμα έναν αριθμό και θα επιστρέφει το άθροισμά του με το 1. 

Το δεύτερο στοιχείο της λίστας θα είναι μία συνάρτηση η οποία θα παίρνει σαν όρισμα έναν αριθμό και θα επιστρέφει το άθροισμά του με το 2

κ.ο.κ.

Το 10ο στοιχείο της λίστας θα είναι μία συνάρτηση η οποία θα παίρνει σαν όρισμα έναν αριθμό και θα επιστρέφει το άθροισμά του με το 10.

Θα πρέπει δηλαδή να μπορώ να γράψω:

```
f()[5](4) --> Τυπώνει 4+6 = 10
f()[0](2) --> Τυπώνει 1+2 = 3
```


### Άσκηση 5
Έστω το παρακάτω string:
```python
'++-+--+-+++++++++++++-+-+++++-++--++-++++-+---++-++-+--++---++-+-++-------+-+++---+---++-+-+++-+-+++'
```

Φτιάξτε μια συνάρτηση που θα παίρνει μία παράμετρο ένα string. Στη συνέχεια θα επιστρέφει τη θέση στο string που βρίσκεται η μεγαλύτερη ακολουθία από συνεχόμενα '+'. Αν η μεγαλύτερη ακολουθία υπάρχει παραπάνω από μία φορά, επιστρέφει τη πιο μικρή θέση.
Για παράδειγμα:

```text
'+--+-+-----+-+--+----+--+---+++-+-+---+-----++----+-++--++++++-+-----++---+--+-+-+-+++++--++-------+' --> 56
'+-+-++--+----+-+---+-+-+---+----+-++-+-+--++++-++++-+++--++++--+----+----+-+++--+-++-+---++-+-------' --> 42
```


### Άσκηση 6
Έστω το παρακάτω string:
```python
'++-+--+-+++++++++++++-+-+++++-++--++-++++-+---++-++-+--++---++-+-++-------+-+++---+---++-+-+++-+-+++'
```
Και έστω η παρακάτω λέξη:
```python
ZABARAKTRANEMIA
```
 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει δύο παραμέτρους. Ένα string μόνο με '+' και '-' και ένα άλλο string με οποιουσδίποτε χαρακτήρες. Η συνάρτησή σας θα πρέπει να αντιστοιχείσει το 2ο string στο 1ο. Με τον εξής τρόπο: Όπου υπάρχει το πρώτο '-' αντιστοιχεί το 1ο γράμμα του 2ου string. Όπου υπάρχει το δεύτερο '-' αντιστοιχεί το 2ο γράμμα του 2ου string κτλ. Αν υπάρχει '+' τότε θα πρέπει να βάζει κενό.  Δεν χρειάζεται να βάζετε κενά μόλις τελειώσει το 2o string. Για παράδειγμα:

```text
ΕΙΣΟΔΟΣ:
'++-+--+-+++++++++++++-+-+++++-++--++-++++-+---++-++-+--++---++-+-++-------+-+++---+---++-+-+++-+-+++'
'ZABARAKATRANEMIA'

ΕΞΟΔΟΣ
   Z AB A             R A     K  AT  R    A NEM  I  A

ΕΞΗΓΗΣΗ
'++-+--+-+++++++++++++-+-+++++-++--++-++++-+---++-++-+--++---++-+-++-------+-+++---+---++-+-+++-+-+++'
   Z AB A             R A     K  AT  R    A NEM  I  A
```

### Άσκηση 7
Δίνεται η παρακάτω λίστα:
```python
[
   'Alekos',
   'Aleksandra',
   'Aleksandros'
]
```
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία λίστα από strings. Θα επιστρέφει το μεγαλύτερο δυνατό υπο-string με το οποία ξεκινάν όλες οι λέξεις της λίστας. Παράδειγμα:

```text
[
   'Alekos',
   'Aleksandra',
   'Aleksandros'
]

--> 'Alek'
```

```text
[
   'Panionios',
   'Panathaikos',
   'Panaitolikos',
]

--> 'Pan'
```

```text
[
	'python',
	'java',
	'assembly',

]

--> ''
```



### Άσκηση 8
Φτιάξτε μία συνάρτηση η οποία θα παίρνει 1 παραμέτρo, ν ακέραιoς. Η συνάρτηση θα πρέπει να επιστρέφει ένα string το οποίο θα είναι το ανάπτυγμα της έκφρασης (α+β)^ν. Παραδείγματα:

```
n=10  Δηλαδή (α+β)^10

--> a^10 + 10a^9b + 45a^8b^2 + 120a^7b^3 + 210a^6b^4 + 252a^5b^5 + 210a^4b^6 + 120a^3b^7 + 45a^2b^8 + 10ab^9 + b^10
```

Χρησιμοποιείστε τη φόρμουλα που περιγράφεται εδώ: https://en.wikipedia.org/wiki/Binomial_theorem για να βρείτε τους παράγοντες του κάθε γινομένου.


### Άσκηση 9
Έστω το παρακάτω string:
```python
'aahtoootoootttuuuu-----------o'
```

Υπάρχει ενας τρόπος να "συμπιέσουμε" αυτό το string, γράφοντας κάθε γράμμα που επαναλαμβάνετε σκολουθούμενο με το πόσες φορές επαναλμβάνεται. Αν το υλοποιήσουμε τότε το string αυτό μπορει να γραφεί ως εξής:
```python
'a2h1t1o3t1o3t2u4-11o1'
```

Φτιάξτε μία συνάρτηση με τον όνομα compress η οποία θα παίρνει ως παράμετρο ένα string s. Η συνάρτηση θα επιστρέφει ένα άλλο string το οποίο θα είναι η συμπίεση του s σύμφωνα με τον τρόπο που παρουσιάστηκε. Υποθέστε ότι το s δεν θα έχει αριθμούς μέσα.

Φτιάξτε μία συνάρτηση με τον όνομα decompress η οποία θα παίρνει ένα συμπιεσμένο string και θα επιστρέφει το αρχικό, αποσυμπιεσμένο string.

### Άσκηση 10
Ένας παίκτης παίζει 100 παρτίδες πόκερ. Σε κάθε παρτίδα σημειώνει πόσα λεφτά κέρδισε ή έχασε. Τα ποσά αυτά τα σημειώνει σε μία λίστα. π.χ.:
```python
[31, -28, 14, -12, -4, 44, 47, 2, -48, -5, -43, 32, 0, -4, 24, -46, -12, 38, -38, -27, -23, -26, 10, 42, 26, -20, -43, -50, 
2, 42, 32, 17, -33, 5, 42, 28, 2, 12, 9, -33, 22, 10, 3, 34, 12, 17, 21, 17, 24, 22, 21, -35, 33, 12, -43, 49, -17, 3, -2, 
-25, -29, -35, -26, -25, -22, -33, 10, 26, -41, 29, 6, -10, 15, -28, -23, -35, -1, -16, 24, -45, -50, -17, 20, 12, -32, 48, 
-48, 2, -41, 4, 5, 29, -36, -46, -6, -17, -18, 16, 42, 42]

```

Σε ποια παρτίδα ο παίκτης είχε τα περισσότερα χρήματα; 
Δηλαδή στη πρώτη παρτίδα ο παίκτης είχε 31. Στη δεύτερη είχε 31-28=3. Στη τρίτη είχε 31-28+14=17. κτλ. Όπως βλέπετε υπάρχουν παρτίδες που ο παίκτης έχασε χρήματα.

Φτιάξτε μία συνάρτηση η οποία θα παίρνει ως παράμετρο μία λίστα από ακέραιους. Θα επιστρέφει τη θέση στην οποία το άθροισμα όλων των αριθμών από την αρχή μέχρι εκείνη τη θέση είναι ο μεγαλύτερος.
Για παράδειγμα η απάντηση στη λίστα που δόθηκε είναι 55 (ξεκινώντας από το 0). 

### Άσκηση 11
Θεωρήστε τον ίδιο παίκτη πόκερ. Ποιες είναι οι συνεχόμενες παρτίδες που είχε το μεγαλύτερο κέρδος; 
Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα με ακέραιους. Η συνάρτηση θα επιστρέφει το υποσύνολο της λίστας από συνεχόμενες τιμές που έχει το μεγαλύτερο άθροισμα. Η απάντηση στη λίστα του παραδείγματος είναι: (28,56). Δηλαδή το άθροισμα όλων των στοιχείων της λίστα απο το 28 μέχρι το 56 είναι και το μεγαλύτερο δυνατό. 

### Άσκηση 12
Για να γίνει ένα κέικ κάποιος μπορεί να επιλέξει μία από 6 διαφορετικές μάρκες βούτηρο. Οι τιμές τους είναι:
```python
[82, 88, 88, 71, 79, 74]
```

Πρέπει επίσης να επιλέξει μία από 8 μάρκες αυγά. Οι τιμές τους είναι:
```python
[73, 91, 82, 98, 95, 90, 70, 73]
```

Πρέπει επίσης να επιλέξει μία από 5 μάρκες γάλα. Οι τιμές τους είναι:
```python
[97, 90, 89, 81, 99]
```

Ποιος είναι ο μέσος όρος όλων των δυνατών τιμών που μπορεί να κοστίσει ένα κέικ;


### Άσκηση 13
Ας υποθέσουμε ότι έχουμε ένα γονίδιο το οποίο έχει μέγεθος 100 νουκλεοτίδια.
Από το γονίδιο αυτό παίρνουμε 20 ακολουθίες. Η κάθε μία ξεκινάει και τελειώνει στις θέσεις που φαίνονται παρακάτω: 
 
```python
[(22, 34), (66, 75), (35, 46), (45, 59), (77, 87), (38, 58), (51, 58), (81, 90), (52, 70), (53, 65), 
(53, 72), (50, 63), (80, 100), (0, 12), (68, 81), (35, 51), (27, 34), (69, 87), (39, 47), (0, 8)]

```

Ποιες θέση του γονιδίου έχουν τη μεγαλύτερη "κάλυψη". Δηλαδή η ακολουθία τους έχει διαβαστεί τις περισσότερες φορές;
Φτιάξτε μία συνάρτηση η οποία θα παίρνει μία λίστα από ζευγάρια από αριθμούς. Η συνάρτηση θα επιστρέφει μία λίστα με τις θέσεις που έχουν τη μεγαλύτερη κάλυψη. Για το παράδειγμα που έχει δοθεί η απάντηση είναι:

```python
[53, 54, 55, 56, 57]
```

### Άσκηση 14
Έστω η λίστα με τα παρακάτω strings:
```python
b = [
    'zabarakatranemia',
    'askardamikth',
    'mpampesika',
]
```

Ποια είναι τα γράμματα που υπάρχουν σε όλα τα strings της λίστας;
Φτιάξτε μία συνάρτηση που θα παίρνει σαν παράμετρο μία λίστα με strings. Θα επιστρέφει μία λίστα με όλα τα γράμματα που υπάρχουν σε όλα τα strings της παραμέτρου. Για παράδειγμα για τη λίστα που δόθηκε, τα γράμματα που υπάρχουν σε όλα strings είναι: ['m', 'k', 'i', 'a']. Προσοχή η λίστα μπορεί να περιέχει και γράμματα πέρα του λατινικού αλφάβητου (ελληνικα, κινέζικα, αραβικά, ...)

### Άσκηση 15
Έστω ο παρακάτω αριθμός:
```
a = 25629456287456291
```

Ποις είναι ο μεγαλύτερος αριθμός ο οποίος υπάρχει μέσα στον a και αποτελείται από ψηφία τα οποία είναι συνεχόμενα;
Για παράδειγμα ο 456 είναι ο μεγαλύτερος αριθμός ο οποίος αποτελείται από συνεχόμενα ψηφία (4,5,6) ο οποίος υπάρχει μέσα στον a.
Φτιάξτε μία συνάρτηση που θα παίρνει σαν παράμετρο τον a και θα επιστρέφει τον ζητούμενο αριθμό. 

### Άσκηση 16
Μία εταιρία φορτηγών κάνει διαδρομές μεταξύ διάφορων πόλεων. Οι πόλεις είναι κωδικοποιημένες από το 0 μέχρι το Ν-1, όπου Ν είναι το πλήθος των πόλεων.
Η εταιρία έχει μία λίστα η οποία λέει αν ένα φορτηγό βρίσκεται σε μια πόλη, τότε ποια πρέπει να είναι η επόμενη. 
Αν υποθέσουμε ότι έχουμε μία λίστα με 10 πόλεις, η λίστα αυτή έχει την εξής μορφή:
```python
[5, 0, 6, 6, 9, 3, 4, 0, 4, 3]
``` 
Ένα φορτηγό πάντα ξεκινάει από τη πόλη 0.

Σύμφωνα με το πίνακα η επόμενη πόλη είναι αυτή που βρίσκεται στη θέση 0, οπότε είναι η 5.

Η επόμενη πόλη είναι αυτή που βρίσκεται στη θέση 5 οπότε είναι η 3.

Η επόμενη πόλη είναι αυτή που βρίσκεται στη θέση 3 οπότε είναι η 6.

Η επόμενη πολη είναι αυτή που βρίσκεται στη θέση 6 οπότε είναι η 4.

Η επόμενη πόλη είναι αυτή που βρίσκεται στη θέση 4 οπότε είναι η 9.

Η επόμενη πόλη είναι αυτή που βρίσκεται στη θέση 9 οπότε είναι η 3.


Παρατηρούμε ότι στη 3 έχει ξαναπάει. Αν το φορτηγό πάει στη 3 τότε θα κάνει "κύκλους". Δηλαδή θα πηγαίνει 3,6,4,9,3,6,4,9,3,6,4,9,3, ....

Δηλαδή ένα φορτηγό το οποίο ξεκινάει από τη θέση 0 της λίστας θα καταλήγει να κάνει κύκλους μεταξύ 4 πόλεων (3,6,4,9). 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει σαν παράμετρο μία λίστα από ακέραιους. 
Η συνάρτηση θα επιστρέφει το μέγεθος του κύκλου (δηλαδή το πλήθος των πόλεων) που θα κάνει ένα φορτηγό, αν ξεκινήσει από τη θέση 0.
Θεωρούμε ότι πάντα υπάρχει κύκλος. Επίσης θα πρέπει η υλοποίησή σας να δουλεύει για αυθαίρετα μεγάλες λίστες.

Μερικά επιπλέον παραδείγματα:

```text
[6, 2, 9, 5, 9, 2, 0, 0, 0, 3] --> 2
[0, 3, 3, 5, 5, 5, 1, 1, 8, 6] --> 1

```

### Άσκηση 17
Ένα ρομποτάκι κινείται σε έναν διδιάστατο χώρο ξεκινώντας από το σημείο 0,0.
Το ρομποτάκι δέχεται σαν είσοδο ένα string το οποιο περιγράφει τα βήματά του. Το string αυτό έχει τα παρακάτω γράμματα:

* ">": πήγαινε δεξιά (π.χ. από το 1,3 --> 2,3)
* "<": πήγαινε αριστερά (π.χ. από το 1,3 --> 0,3)
* "v": πήγαινε κάτω (π.χ. από το 1,3 --> 1,2)
* "^": πήγαινε πάνω (π.χ. από το 1,3 --> 1,4)

Για παράδειγμα μία ακολουθία μπορεί να είναι:
```
^>v<
```
Δηλαδή πήγαινε πάνω, μετά δεξιά, μετά κάτω μετά αριστερά.

Φτιάξτε μία συνάρτηση η οποία θα δέχεται ένα string το οποίο θα έχει μόνο τους χαρακτήρες: "<", ">", "^", "v". Θα επιστρέφει το πλήθος από τις θέσεις τις οποίες το ρομποτάκι έχει επισκεφθεί μία και μόνο φορά. Θεωρείστε ότι το 0,0 είναι η θέση που ξεκινάει οπότε πριν ακόμα αρχίσει να κινείται, έχει επισκεφθεί αυτή τη θέση 1 φορά (μπορεί όμως στο μέλλον να τη ξαναεπισκεφθεί).

Παραδείγματα:
```text
'v>v<vvv<<vv^v<v>vv>v<<<^^^^^<<^<vv>^>v^>^>^>^>^><vvvv<^>^<<^><<<^vvvv>^>^><^v^><^<>^^>^vvv^<vv>>^>^^<>><>^>vvv>>^vv>^<><>^<v^>^>^><vv^vv^>><<^><<v>><>^<^>>vvv>v>>>v<<^<>'
--> 53

'<^<v<>v>^^v^^^<^v^^>>><^>^>v<>^<>>^>^^v^><v<v>>><>v<v^v>^v<>>^><v>^<>v^>^<>^v^^^v^^>>vv<<^^><^<vvv>^>^^<^>>^^^^^v^<v>vv<>>v^v<^v^^<><^<^vv^><>><><>v>vvv^vv^^<<><<vvv><<^v^>'
--> 33
```

### Άσκηση 18
Θεωρείστε το ίδιο ρομποτάκι με τη προηγούμενη άσκηση. Αλλάξτε τη συνάρτηση έτσι ώστε να επιστρέφει το πλήθος από θέσεις που ΔΕΝ έχει επισκεφτεί. 
Για να το κάνετε αυτό υπολογίστε το εξής:
* Ποια είναι η πιο δεξιά θέση που έχει επισκεφθεί; Έστω η 4
* Ποια είναι η πιο αριστερή θέση που έχει επισκεφθεί; Έστω η -3
* Ποια είναι η πιο πάνω θέση που έχει επισκεφθεί; Έστω η 2
* Ποια είναι η πιο κάτω θέση που έχει επισκεφθεί; Έστω η -1

Πάρτα όλα τις θέσεις που υπάρχουν στο παραλληλόγραμμο που ορίζονται από αυτές τις "ακραίες" θέσεις. Για παράδειγμα.
```
(-3, 2)  (-2, 2)  (-1, 2)  (0, 2)  (1, 2)  (2, 2)  (3, 2)  (4, 2)
(-3, 1)  (-2, 1)  (-1, 1)  (0, 1)  (1, 1)  (2, 1)  (3, 1)  (4, 1)
(-3, 0)  (-2, 0)  (-1, 0)  (0, 0)  (1, 0)  (2, 0)  (3, 0)  (4, 0)
(-3, -1) (-2, -1) (-1, -1) (0, -1) (1, -1) (2, -1) (3, -1) (4, -1)
```

Υπολογίστε το πλήθος από αυτές τις θέσεις που το ρομποτάκι ΔΕΝ έχει επισκεφτεί.
Για παράδειγμα:
```text
a = 'v>v<vvv<<vv^v<v>vv>v<<<^^^^^<<^<vv>^>v^>^>^>^>^><vvvv<^>^<<^><<<^vvvv>^>^><^v^><^<>^^>^vvv^<vv>>^>^^<>><>^>vvv>>^vv>^<><>^<v^>^>^><vv^vv^>><<^><<v>><>^<^>>vvv>v>>>v<<^<>'
--> 168

'<^<v<>v>^^v^^^<^v^^>>><^>^>v<>^<>>^>^^v^><v<v>>><>v<v^v>^v<>>^><v>^<>v^>^<>^v^^^v^^>>vv<<^^><^<vvv>^>^^<^>>^^^^^v^<v>vv<>>v^v<^v^^<><^<^vv^><>><><>v>vvv^vv^^<<><<vvv><<^v^>'
--> 257


```


### Άσκηση 19
Έστω ότι έχουμε τις παραπάνω θέσεις σε ένα διδιάστατο χώρο
```
[(-34, 7),
 (-66, -36),
 (-50, 33),
 (95, 0),
 (-86, 48),
 (46, -27),
 (-39, -46),
 (53, -87),
 (-26, 37),
 (13, -37)]
```

Έχουμε δηλαδή 10 σημεία. Ο πρώτος αριθμός είναι η συντεταγμένη του στο x και ο δεύτερος στο y. Δηλαδή ο πρώτος αριθμός είναι στο -34,7 του διδιάστατου χώρου. Ορίζεται η ευκλίδεια απόσταση μεταξώ δύο σημείων a,b:
```python
import math
def euclidean(a,b):
	return math.sqrt((a[0]-b[0])**2 + (a[1]-b[1])**2)
```

Ορίζουμε επίσης τη μέση θέση δύο σημείων ως το μέσο της ευθείας που τα συνδέει:
```python
def mesh_thesh(a,b):
	# This function returns 2 numbers! 
	return (a[0]+b[0])/2, (a[1]+b[1])/2
```

Στη συνέχεια εφαρμόζουμε τον παρακάτω αλγόριθμο: Βρίσκουμε τα δύο σημεία τα οποία είναι πιο κοντά με βάση την ευκλίδεια απόσταση. Αφού τα βρούμε, διαγράφουμε το ένα από τη λίστα και το άλλο το αντικαθιστούμε με τη μέση θέση των δύο σημείων αυτών. Άρα στο τέλος θα μείνουμε με μία λίστα με 9 σημεία. Επαναλαμβάνουμε αυτή τη διαδικασία μέχρι να μείνει ένα σημείο στη λίστα. Στη συνέχεια βρίσκουμε ποιο σημείο από την αρχική λίστα είναι πιο κοντά στο ένα στοιχείο που έμεινε. Φτιάχτε μία συνάρτηση που θα δέχεται σαν όρισμα μία λίστα με σημεία στον διδιάστατο χώρο και να επιστρέφει το σημείο της λίστας το οποίο είναι πιο κοντά στο ένα σημείο που υπολογίστηκε όπως περιγράφηκε παραπάνω. 

Παράδειγμα
```text
[(-34, 7),
 (-66, -36),
 (-50, 33),
 (95, 0),
 (-86, 48),
 (46, -27),
 (-39, -46),
 (53, -87),
 (-26, 37),
 (13, -37)]

--> 9
```

```text
[(58, -50),
 (-67, 34),
 (-77, 40),
 (-19, -23),
 (-53, -66),
 (39, 15),
 (-85, -14),
 (42, 81),
 (-4, -59),
 (71, 15)]

--> 3
```

```text
[(44, 29),
 (31, 1),
 (-14, 79),
 (98, -78),
 (-2, 34),
 (-80, -27),
 (98, -21),
 (25, -23),
 (33, 45),
 (-85, -40),
 (53, 81),
 (50, -53),
 (42, 56),
 (-30, 100),
 (74, 20),
 (-78, -80),
 (-39, 42),
 (87, 19),
 (15, 98),
 (85, -27)]
 
 --> 7
 ```


### Άσκηση 20 (Εξαιρετικά δύσκολη)
Δίνεται η παρακάτω λίστα:
```
[[673, 517, 674, 834, 991, 458, 558, 538, 990],
 [758, 469, 850, 940, 889, 937, 978, 703],
 [925, 838, 595, 880, 767, 685, 659],
 [589, 455, 858, 808, 748, 837],
 [586, 994, 875, 779, 945],
 [979, 685, 661, 817],
 [498, 814, 940],
 [597, 687],
 [844]]
```

Η λίστα αυτή περιέχει τις αποστάσεις μεταξύ 10 πόλεων. 
Η 1η πόλη απέχει από τη 2η 673.

Η 1η πόλη απέχει από τη 3η 517.

Η 1η πόλη απέχει από τη 4η 674.

Η 1η πόλη απέχει από τη 10η 990.

Η 2η πόλη απέχει από τη 3η 758.

Η 2η πόλη απέχει από τη 4η 469.

Η 2η πόλη απέχει από τη 10η 703.

Η 8η πόλη απέχει από τη 9η 597.

Η 8η πόλη απέχει από τη 10η 687.

Η 9η πόλη απέχει απο τη 10η πόλη 844.

Εννοείται επίσης ότι η απόσταση μεταξύ της πόλης Α και Β είναι ίδια με την απόσταση της Β με την Α..

Ένα φορτηγό θέλει να ξεκινήσει από τη 1η πόλη και να καταλήξει πάλι στη 1η πόλη έχοντας επισκεφτεί όλες τις υπόλοιπες πόλεις ακριβώς 1 φορά τη κάθε μία. 
Με ποια σειρά πρέπει να τις επισκεφτεί ώστε να κάνει τη μικρότερη δυνατή απόσταση;

Φτιάξτε μία συνάρτηση η οποία θα παίρνει ως παράμετρο μία λίστα σαν αυτή του παραδείγματος.
Η συνάρτηση θα επιτρέφει μία λίστα με τη σειρά των πόλεων που ελαχιστοποιούν την απόσταση. Για παράδειγμα:

```text
Για το παράδειγμα που δόθηκε: --> [0, 6, 7, 8, 2, 9, 1, 3, 5, 4, 0]
```

```text
# Ένα άλλο παράδειγμα

[[518, 711, 908, 526, 431, 731, 898, 661, 487],
 [586, 634, 850, 668, 441, 624, 699, 728],
 [910, 895, 928, 536, 875, 747, 477],
 [679, 909, 572, 543, 728, 734],
 [871, 599, 615, 836, 715],
 [739, 874, 994, 544],
 [859, 624, 742],
 [886, 528],
 [740]]

--> [0, 5, 9, 2, 1, 6, 4, 7, 3, 8, 0]
```

Στις λύσεις που έχω βάλει εδώ, 0 είναι η 1η πόλη .... 9 είναι η 10η πόλη.

Αυτό το πρόβλημα είναι γνωστό σαν [Travelling Salesman Problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem).
Το πρόβλημα ανοίκει σε μία ιδιαίτερη κατηγορία προβλημάτων: Αυτή που δεν υπάρχει καλύτερη λύση (ή μάλλον δεν έχει βρεθεί ακόμα..) πέρα της εξαντλητικής. Δηλαδή το να πάρεις όλες τις πιθανές διαδρομές και να βρεις τη πιο σύντομη, είναι αυτή τη στιγμή ο καλύτερος αλγόριθμος που υπάρχει!

Μην σας ανησυχεί όμως αυτό. Για τα μεγέθη που βάζουμε σε αυτή την άσκηση, ο υπολογιστής σας μπορεί να βρει τη λύση σε μερικά δευτερόλεπτα!


SET 3

## Μέρος Α

Για τις επόμενες ασκήσεις θα πρέπει να κατεβάσετε το αρχείο που βρίσκετε στο εξής link: https://raw.githubusercontent.com/washingtonpost/data-game-of-thrones-deaths/master/game-of-thrones-deaths-data.csv 

Ένας τρόπος για να το κατεβάσετε είναι το τρέξετε την εντολή:

```bash
wget https://raw.githubusercontent.com/washingtonpost/data-game-of-thrones-deaths/master/game-of-thrones-deaths-data.csv  
```

Αυτό το αρχείο είναι σε μορφή [csv](https://en.wikipedia.org/wiki/Comma-separated_values). 
Περιέχει όλους τους.. θανάτους που έγιναν στο [Game of Thrones](https://www.imdb.com/title/tt0944947/). 
Περισσότερα για το αρχείο αυτό μπορείτε να διαβάσετε [εδώ](https://github.com/washingtonpost/data-game-of-thrones-deaths), ενώ [εδώ](https://www.washingtonpost.com/graphics/entertainment/game-of-thrones/) υπάρχει μία παρουσίασή του.

Η πρώτη γραμμή του αρχείου περιέχει την επικεφαλίδα (header) με τα εξής πεδία:
```
order,season,episode,character_killed,killer,method,method_cat,reason,location,allegiance,importance
```

* order: Η σειρά με την εοποία έγινε ο θάνατος
* season: H σεζόν
* episdose: Το επεισόδιο της σεζόν
* character_killed: Ποιος πέθανε
* killer: Ποιος τον σκότωσε
* method: Με ποιον τρόπο τον σκότωσε
* method_cat: Η κατηγορία του τρόπου που τον σκότωσε
* reason: Ο λόγος για τον οποίο τον σκότωσε
* location: Ο τόπος που σκοτώθηκε
* allegiance: Σε ποια φατρία/οικογένεια/φυλή ανοίκει αυτός που πέθανε
* importance: Ένας αριθμός από το 1 μέχρι το 4. Υποδηλώνει πόσο σημαντικό για την πλοκή είναι ο θάνατος. 1=ασήμαντος, 4=πολύ σημαντικός.

Δίνεται επίσης ο εξής κώδικας για να αποθηκεύσετε όλα τα δεδομένα σε μία λίστα:

```python
import csv

order_index = 0
season_index = 1
episode_index = 2
character_killed_index = 3
killer_index = 4
method_index = 5
method_cat_index = 6
reason_index = 7
location_index = 8
allegiance_index = 9
importance_index = 10

data = []
with open('game-of-thrones-deaths-data.csv', newline='') as f:
    reader = csv.reader(f, delimiter=',', quotechar='"')
    header = f.readline().strip().split(',')
    for ls in reader:
        d = {
            'order': int(ls[order_index]),
            'season': int(ls[season_index]),
            'episode': int(ls[episode_index]),
            'character_killed': ls[character_killed_index],
            'killer': ls[killer_index],
            'method': ls[method_index],
            'method_cat': ls[method_cat_index],
            'reason': ls[reason_index],
            'location': ls[location_index],
            'allegiance': ls[allegiance_index],
            'importance': int(ls[importance_index]) if ls[importance_index] else 1,
        }
        data.append(d)
```

Κάθε στοιχείο της λίστας είναι ένα dictionary με όλα τα πεδία. 

Εσείς θα πρέπει να γράψετε κώδικα που να απαντάει στα εξής ερωτήματα (εννοείται ότι δεν χρειάζεται να έχετε παρακολουθήσει τη σειρά για να απαντήσετε): 

###  Άσκηση 1
Πόσοι θάνατοι έχουν importance μεγαλύτερο από 1;

### Άσκηση 2
Από όσους έχουν importance μεγαλύτερο από 1, πόσοι έχουν σκοτωθεί από την Arya Stark;

### Άσκηση 3
Σε ποια σεζόν έχει σκοτώσει περισσότερους ο Jon Snow; Πάρτε μόνο όσους έχουν importance μεγαλύτερο από 1.

### Άσκηση 4
Πόσες διαφορετικές κατηγορίες θανάτου (method_cat) υπάρχουν;

### Άσκηση 5
Για κάθε διαφορετική κατηγορία θανάτου, σε ποιά φατρία/οικογένεια/φυλή ανοίκουν τα μέλη που έχουν σκοτωθεί τις περισσότερες φορές από αυτή τη κατηγορία; Πάρτε μόνο θανάτους με importance>1

### Άσκηση 6
Ποιος έχει κάνει τους 2ους περισσότερους φόνους με importance>1;

### Άσκηση 7
Ποιος είναι ο λόγος (reason) που προκάλεσε τους περισσότερους θανάτους με importance>2;

### Άσκηση 8
Σε ποια επεισόδια δεν έγινε κανένας θάνατος; (τυπώστε και τη σεζόν του κάθε επεισοδίου)

### Άσκηση 9
Αν πάρουμε όλα τα διαφορετικά ζευγάρια (θύτης,θύμα) και όλα τα διαφορετικά ζευγάρια (θύμα,θήτης), πόσα κοινά στοιχεία υπάρχουν μεταξύ τους;

### Άσκηση 10
Πόσος είναι ο μέσος όρος θανάτων ανά επεισόδια για κάθε σεζόν; Δηλαδή για κάθε σεζόν (8 συνολικά), τυπώστε τον μέσο όρο από θανάτους που είχε το κάθε επεισόδιο αυτής της σεζόν. 

### Άσκηση 11
Πόσοι είναι αυτοί που έχουν σκοτώσει αλλά δεν έχουν σκοτωθεί;

### Άσκηση 12 (εξαιρετικά δύσκολη)
Ας υποθέσουμε ότι έχουμε μία σειρά από φόνους: ο Α σκοτώνεται από τον Β, ο Β σκοτώνεται από τον Γ και τέλος ο Γ σκοτώνεται από τον Δ. Έχουμε δηλαδή μία σειρά από 4 φόνους όπου ο ν-οστός σκοτώνεται από το (ν+1)-στο. Ποια είναι η μεγαλύτερη αλυσίδα από φόνους που βλέπουμε στο games of thrones;

Πάρτε μόνο τους θάνατους με importance > 2

Hint: Στην ουσία ζητάμε να βρούμε τη μεγαλύτερη διαδρομή σε έναν γράφο όπου κόμβοι είναι ήρωες και ακμές είναι.. φόνοι. Μπορείτε να προσαρμόσετε τον κώδικα που υπάρχει εδώ: https://stackoverflow.com/questions/29320556/finding-longest-path-in-a-graph . 

## Μέρος Β

Και επειδή πολύ μελαγχολικό ήταν το θέμα των ασκήσεων μέχρι στιγμής, θα ασχοληθούμε με κάτι πολύ πιο ευχάριστο όπως... η eurovision!
Συγκεκριμένα θα ασχοληθούμε με τη [eurovision του 2016](https://en.wikipedia.org/wiki/Eurovision_Song_Contest_2016).

Για όσους δεν το ξέρουν, κάθε χώρα βαθμολογεί μία άλλη χωρά με 1,2,3,4,5,6,7,8,10 ή 12 βαθμούς. 
Επίσης υπάρχουν δύο βαθμολογίες, αυτή του κοινού (televoting) και αυτή μιας ομάδας κριτών (jury).

Για αρχή λοιπόν θα πρέπει να κατεβάσουμε τα επίσημα αποτελέσματα του τελικού:

* Πηγαίνετε εδώ: https://eurovision.wetransfer.com/downloads/a1da4b5eb0395e58b71016dce076564a20170409152448/6754ae
* Πατήστε "I agree" (αν φυσικά συμφωνείτε)
* Επιλέξτε και κατεβάστε το αρχείο "ESC-2016-grand_final-full_results.xls", το οποίο περιέχει τις ψήφους για τον τελικό του 2016

Στη συνέχεια μπορούμε να ανοίξουμε το αρχείο αυτό από python και να το επεξεργαστούμε ως εξής:

```python
import pandas as pd

df = pd.read_excel('ESC-2016-grand_final-full_results.xls') # Αγνοήστε τα warnings..

data = []

for k,v in df.to_dict('index').items():
    if k==0:
        continue
    
    d = {
        'from_country': v['Eurovision Song Contest 2016 Grand Final'],
        'to_country': v['Unnamed: 1'],
        'jury_points': 0 if v['Unnamed: 9']=='\n' else int(v['Unnamed: 9']),
        'televote_points': 0 if v['Unnamed: 10']=='\n' else int(v['Unnamed: 10']),
    }
    
    data.append(d)

```

Σημείωση: αν δεν έχετε pandas, μπορείτε να την εγκαταστήσετε με:
```
!pip install pandas 
```

Αφού τρέξει λοιπόν αυτό, θα έχετε μία λίστα από dictionaries. Κάθε dictionary περιέχει πόσους πόντους έδωσε κάθε χώρα (from_country) σε κάθε χώρα (to_country). Κάθε χώρα έδωσε δύο ειδών βαθμούς: (1) από τους κριτές  (jury_points) και από το "κοινό" (televote_points).  Για παράδειγμα:

```python
data[1000]

{'from_country': 'The Netherlands',
 'to_country': 'France',
 'jury_points': 5,
 'televote_points': 4}
```

Η Ολλανδία έδωσε στη Γαλλία 5 πόντους σύμφωνα με τους κριτές και 4 πόντους σύμφωνα με το κοινό. 

Τώρα είμαστε έτοιμοι να απαντήσουμε σε μερικά καίρια ερωτήματα:

### Άσκηση 13
Εντοπίστε τα σκάνδαλα! Ποιες είναι οι 10 μεγαλύτερες διαφωνίες μεταξύ των ψήφων του κοινού και των ψήφων των κριτών; Πάρτε την απόλυτη διαφορά τους. 

### Άσκηση 14
Ποια χώρα είναι η πιο.. αδικημένη; Δηλαδή έχει τη μεγαλύτερη διαφορά μεταξύ των ψήφων του κοινού και των ψήφων των κριτών;

### Άσκηση 15
Καθως έχουμε ψύχωση με τις αδικίες στη eurovision, θα προσπαθήσουμε να βρούμε τη πιο αδικημένη χώρα με έναν άλλο τρόπο:
Έστω Α η κατάταξη μίας χώρας αν πάρουμε μόνο τις ψήφους του κοινού (δηλαδή αν Α=1 τότε είναι πρώτη). Έστω Β η κατάταξή της αν πάρουμε όλους τους ψήφους. Για ποια χώρα η διαφορά Β-Α είναι η μεγαλύτερη;

### Άσκηση 16
Φτιάξτε ένα dictionary: Τα keys είναι οι χώρες και τα values είναι λίστα με τις χώρες που ψήφισαν το key με φθίνουσα σειρά βαθμών (κριτές + κοινό) που έδωσαν. Για παράδειγμα αν d είναι το dictionary τότε θα πρέπει:

```python
print (d['Australia'])

['Sweden',
 'Albania',
 'Denmark',
 'Norway',
 'Iceland',
 'The Netherlands',
 'Poland',
 'Lithuania',
 'Croatia',
 'Belgium',
 'Moldova',
 'Malta',
 'Israel',
 'Hungary',
 'Finland',
 'Cyprus',
 'Austria',
 'United Kingdom',
 'Estonia',
 'Switzerland',
 'Bulgaria',
 'Bosnia & Herzegovina',
 'Spain',
 'Serbia',
 'Greece',
 'Latvia',
 'Germany',
 'F.Y.R. Macedonia',
 'Ukraine',
 'Slovenia',
 'Georgia',
 'Azerbaijan',
 'Belarus',
 'Russia',
 'Italy',
 'Ireland',
 'France',
 'San Marino',
 'Armenia',
 'Montenegro',
 'Czech Republic']
```

### Άσκηση 17
Φτιάξτε ένα αρχείο "votes.txt". Το αρχείο θα πρέπει να έχει γραμμές τόσες όσες οι χώρες που πήραν μέρος στον τελικό, συν 1. Θα πρέπει να έχει στήλες τόσες όσες οι χώρες που ψήφισαν, συν 1.
H πρώτη γραμμή θα έχει τη λίστα με όλες τις χώρες που ψήφισαν (με όποια σειρά θέλετε).
Η πρώτη στήλη θα έχει τη λίστα με όλες τις χώρες που πήραν μέρος στον τελικό. 
Στη σημείο x,y (γραμμή x,y) θα έχει τους πόντους που έδωσε η χώρα y στη χώρα x. 
Χρησημοποιήστε το ',' για να διαχωρίσετε τα πεδία. Για παράδειγμα το αρχείο που θα φτιάξετε μπορεί να έχει αυτή τη μορφή:

```text
COUNTRY,Armenia,Australia,Austria,Azerbaijan,Belgium,Bulgaria,Croatia,Cyprus,Czech Republic,France,Georgia,Germany,Hungary,Israel,Italy,Latvia,Lithuania,Malta,Poland,Russia,Serbia,Spain,Sweden,The Netherlands,Ukraine,United Kingdom
Armenia,0,0,2,0,7,20,4,16,8,14,12,2,1,8,1,6,4,7,2,24,5,18,4,10,7,0
Australia,5,0,15,9,16,13,17,15,1,6,9,11,15,15,6,11,17,15,17,6,12,12,24,17,9,14
Austria,4,3,0,0,8,4,6,0,4,16,0,7,6,3,0,4,1,0,4,8,0,2,5,14,0,0
Azerbaijan,0,0,0,0,0,1,0,2,6,0,7,0,7,2,0,3,0,6,0,16,0,2,10,1,17,0
Belgium,4,24,5,0,0,10,0,0,2,4,10,5,0,7,0,0,5,0,0,0,5,0,0,16,10,0
Bulgaria,7,18,5,16,11,0,1,12,5,15,3,4,4,14,7,2,2,18,6,0,12,12,4,1,3,13
Croatia,0,1,6,0,0,0,0,1,8,0,2,0,0,3,0,0,0,0,0,0,4,0,0,0,0,1
Cyprus,12,0,0,0,0,7,1,0,0,0,0,0,5,0,7,0,0,5,1,11,3,0,0,0,0,9
Czech Republic,1,0,4,0,1,0,10,0,0,0,0,0,2,0,0,0,0,0,4,0,0,0,3,0,0,0
France,19,13,8,4,16,0,10,13,5,0,4,0,1,20,12,0,4,8,1,10,0,17,11,9,0,6
Georgia,18,0,0,1,7,3,0,0,0,0,0,8,0,0,6,2,14,0,8,5,0,0,0,0,9,12
Germany,0,0,2,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
Hungary,3,0,0,11,0,0,8,8,13,0,2,0,0,0,0,0,2,5,6,1,10,10,0,0,2,0
Israel,0,10,0,9,2,2,7,5,0,3,3,12,0,0,8,2,6,1,7,0,7,1,0,7,6,3
Italy,0,0,0,0,10,0,3,3,0,12,0,4,0,0,0,0,0,15,0,0,0,8,0,6,0,0
Latvia,0,0,0,0,0,0,0,0,1,0,13,2,8,5,0,0,19,0,11,4,0,0,0,0,13,3
Lithuania,0,8,1,5,0,1,0,3,3,0,10,1,3,1,2,18,0,0,2,0,8,0,8,0,15,16
Malta,13,6,10,11,0,7,0,6,6,4,0,0,10,0,5,4,0,0,0,8,10,6,7,0,0,0
Poland,1,0,12,5,12,6,4,2,7,7,4,10,8,4,10,5,9,0,0,5,0,5,10,10,8,10
Russia,14,5,11,24,6,18,14,22,10,7,8,12,10,10,8,19,8,14,8,0,13,12,14,3,12,7
Serbia,0,0,4,0,0,5,14,0,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,0,0,2
Spain,3,7,0,1,0,4,0,0,0,4,0,0,5,4,12,0,0,2,5,0,0,0,2,0,0,4
Sweden,2,0,15,0,1,3,7,1,14,7,6,18,11,0,2,15,7,0,10,2,1,1,0,12,5,1
The Netherlands,0,3,6,0,14,2,0,0,7,7,0,7,8,0,4,3,0,3,0,0,5,3,7,0,0,0
Ukraine,10,10,10,20,5,10,10,7,12,10,22,13,12,20,22,22,18,4,24,10,19,7,7,10,0,15
United Kingdom,0,8,0,0,0,0,0,0,4,0,0,0,0,0,0,0,0,13,0,6,2,0,0,0,0,0
```

### Άσκηση 18
Φτιάξτε έναν generator ο οποίος θα κάνει generate [composite numbers](https://en.wikipedia.org/wiki/Composite_number). 
Ένας composite number είναι ένας αριθμός που ΔΕΝ είναι πρώτος.
Για παράδειγμα, αν gen είναι ο generator που έχετε φτιάξει, θα πρέπει να μπορώ να γράψω:

```python
g = gen()     
for i in range(10):
    print (next(g))

Τυπώνει:

4
6
8
9
10
12
14
15
16
18

```

### Άσκηση 19
Χρησιμοποιώντας τον generator της άσκησης 18, γράψτε έναν άλλο generator ο οποίος τυπώνει το [τρέχων άθροισμα](https://en.wikipedia.org/wiki/Running_total) όλων των composite number. Δηλαδή τη πρώτη φορά τυπώνει 4, τη δεύτερη 4+6, τη τρίτη 4+6+8. Κτλ. Αν η μέθοδός σας υπολογίζει κάθε φορά ξανά όλους του composite numbers, θα είναι λάθος!

Αν running_total είναι ο generator που έχετε φτιάξει, Θα πρέπει να μπορώ να γράφω:

```python
g = running_total()
for i in range(10):
    print (next(g))

Τυπώνει:

4
10
18
27
37
49
63
78
94
112
```

### Άσκηση 20 (Εξαιρετικά δύσκολη)
Ο αριθμός 41 είναι πρώτος. Ο αριθμός 41 έχει και μια άλλη ιδιότητα. Μπορεί να γραφεί σαν άθροισμα από συνεχόμενους πρώτους:

```text
41 = 2 + 3 + 5 + 7 + 11 + 13
```

Επίσης παρατηρούμε ότι το πλήθος από συνεχόμενους πρώτους είναι: 6

Αυτό είναι και το μεγαλύτερο πλήθος από συνεχόμενους πρώτους, που αν τους προσθέσεις θα βγεί πρώτος μικρότερος του 100. 

Ομοίως το μεγαλύτερο πλήθος από συνεχόμενους πρώτους που αν τους προσθέσεις θα βγει πρώτος μικρότερος του 1000, είναι 21, ενώ το άθροισμά τους είναι 953:

```text
953 = 7 + 11 + 13 + 17 + 19 + 23 + 29 + 31 + 37 + 41 + 43 + 47 + 53 + 59 + 61 + 67 + 71 + 73 + 79 + 83 + 89
```


Ποιος είναι ο πρώτος αριθμός, μικρότερος από το 1.000.000, που μπορεί να γραφεί σαν το μεγαλύτερο άθροισμα συνεχόμενων πρώτων αριθμών;

Κάποια hints βρίσκονται εδώ: https://stackoverflow.com/questions/25696076/consecutive-prime-sum 

[πηγή](https://projecteuler.net/problem=50)


SET 4


## Μέρος 1ο. Regular expressions

### Άσκηση 1

Γράψτε **ένα** regular expression το οποίο θα εξάγει όλα τα κομμάτια του κειμένου τα οποία βρίσκονται μεταξύ δύο αριθμών.  
Για παράδειγμα:

```
228djj21  --> ['djj']
421   a  d dd8 --> ['   a  d dd']
abcdefg --> []
fdsd2342dfdf --> []
abcd123defg456kkk777 --> [defg, kkk]
```

### Άσκηση 2
Γράψτε **ένα** regular expression το οποίο θα μπορεί να εντοπίζει ελληνικά κινητά τηλέφωνα. Θα πρέπει να εντοπίζει μέσα σε ένα κείμενο τηλέφωνα όπως:

```
6912345678
00306912345678
+306912345678
```
ΔΕΝ θα πρέπει να εντοπίζει τηλέφωνα όπως:

```
691234567 # Δεν έχει 10 ψηφία
7912345678 # Δεν αρχίζει από 69
+316912345678 # Ο διεθνής κωδικός της Ελλάδας δεν είναι το +31 (είναι το +30)
00316912345678 # Ο διεθνής κωδικός της Ελλάδας δεν είναι το +31 (είναι το +30)
```

### Άσκηση 3
Ο αριθμός [ΑΜΚΑ]((https://www.amka.gr/tieinai.html) αποτελείται από έντεκα (11) αριθμούς και αναλύεται ως κάτωθι:
* Πχ ΑΜΚΑ=18076020025 
* Οι έξι πρώτοι αριθμοί αποτελούν την ημερομηνία γέννησης πχ  180760
* Οι τρείς επόμενοι αποτελούν αριθμούς που δίδει η μηχανογράφηση 
* Ο δέκατος είναι η ένδειξη του φύλου (1=ανδρας , 2=γυναίκα) οι ζυγοί αριθμοί 0,2,4,6,8 δίδονται στις γυναίκες ενώ οι μονοί αριθμοί 1,3,5,7,9 στους άνδρες. 
* Ο τελευταίος (5) είναι [αντικώδικας](https://el.wikipedia.org/wiki/%CE%91%CE%BB%CE%B3%CF%8C%CF%81%CE%B9%CE%B8%CE%BC%CE%BF%CF%82_%CF%84%CE%BF%CF%85_%CE%9B%CE%BF%CF%85%CE%BD) 

Φτιάξτε μία συνάρτηση η οποία θα παίρνει ένα AMKA. Αν ο ΑΜΚΑ δεν είναι στο σωστό φορμάτ, θα πετάει exception. 
Θα πρέπει να ελέγχει ότι: (1) η ημερομηνία υπάρχει και ότι (2) το τελευταίο ψηφίο είναι το σωστό. 

H συνάρτηση θα επιστρέφει True αν ανήκει σε γυναίκα και False αν ανήκει σε άντρα.

Tα διάφορα "κομμάτια" του ΑΜΚΑ θα πρέπει να τα παίρνει με regular expressions.

Δίνεται ο παρακάτω κώδικας ο οποίoς ελέγχει αν μία ημερομηνία είναι σωστή ή όχι (επιτρέφει True αν είναι σωστή και False διαφορετικά)

```python
import datetime

def check_date(year, month, day):
	try:
		datetime.datetime(year=year,month=month,day=day)
	except ValueError:
		return False

	return True

check_date(2019, 2, 28) # Επιστρέφει True
check_date(2019, 2, 29) # Επιστρέφει False
```

Δίνεται ο παρακάτω αλγόριθμος ([κλεμμένος από wikipedia](https://el.wikipedia.org/wiki/%CE%91%CE%BB%CE%B3%CF%8C%CF%81%CE%B9%CE%B8%CE%BC%CE%BF%CF%82_%CF%84%CE%BF%CF%85_%CE%9B%CE%BF%CF%85%CE%BD)) ο οποίος ελέγχει αν το τελευταίο ψηφίο του AMKA είναι το σωστό:

```python
def luhn_checksum(card_number):
    def digits_of(n):
        return [int(d) for d in str(n)]
    digits = digits_of(card_number)
    odd_digits = digits[-1::-2]
    even_digits = digits[-2::-2]
    checksum = sum(odd_digits)
    for d in even_digits:
        checksum += sum(digits_of(d*2))
    return checksum % 10

def is_luhn_valid(card_number):
    return luhn_checksum(card_number) == 0

print (18076020025) # Επιστρέφει True
print (18076020026) # Επιστρέφει False
```

### Άσκηση 4
Οι ελληνικές πινακίδες στα Ι.Χ οχήματα έχουν 2 ή 3 γράμματα ακολουθούμενα από 4 αριθμούς. Τα γράμματα που επιτρέπονται είναι τα Α,Β,Ε,Ζ,Η,Ι,Κ,Μ,Ν,Ο,Ρ,Τ,Υ,Χ (αυτά δηλαδή που υπάρχουν λατινικά αντίστοιχα). Επίσης ο 4ψήφιος αριθμός δεν μπορεί να αρχίζει από 0. Γράψτε **ένα** regular expression το οποίο να αναγνωρίζει αν ένα string περιέχει μία ελληνική πινακίδα. Χρησιμοποιήστε μόνο λατινικούς χαρακτήρες.

π.χ.
```
HPK1234 # OK
HRK0123 # NOT OK 
HCT1234 # NOT OK
HR12345 # NOT OK
HT1234 # OK 
ΗΡΚ12345 # ΝΟΤ ΟΚ
```

### Άσκηση 5
Στο παρακάτω κείμενο βρείτε με ένα regular expression, όλα τα strings που αρχίζουμε με ```$``` και τλειώνου με ```$```

```latex
We try to quantitatively capture these characteristics by defining a set of indexes, which can be computed using the mosaic image and the corresponding ground truth:
\begin{itemize}
    \item $\mu_{A_T}$ and $\sigma_{A_T}$, the mean and standard deviation of the tiles area $A_T$, respectively;
    \item $\rho_\text{filler}$, the ratio between the filler area and the overall mosaic are, computed as $\rho_\text{filler}=\frac{\sum_{T \in \mathcal{T} A_T}}{A}$, being $A$ the area of the mosaic;
    \item \todo{does it worth?};
    \item \todo{does it worth?};
    \item $\mu_{C_T}$, the mean of the tiles \emph{color dispersion} $C_T$, being $C_T = \sigma_R+\sigma_G+\sigma_B$, where $\sigma_R$, $\sigma_G$ and $\sigma_B$ are the standard deviation of the red, green and blue channel values of the pixels within the tile $T$.
After applying a method to an image, we compare the segmented image (i.e., the result) against the ground truth and assess the performance according to the following three metrics:
\begin{itemize}
    \item average tile precision $P$
    \item average tile recall $R$
    \item tile count error $C$
\end{itemize}
Let $T$ be a tile on the ground truth $\mathcal{T}$ with area $A_T$.
Let $T'$ be the tile in the segmented image which mostly overlaps $T$ and let $A_{T'}$ be the area of $T$; let $A_{T \cap T'}$ be the overlapping area between $T$ and $T'$.
Let $n$ and $n'$ the number of tiles respectively in the ground truth and in the segmented image.
Metrics are defined as:
\begin{align}
    P &amp;= \frac{1}{n} \sum_{T \in \mathcal{T}} \frac{A_{T \cap T'}}{A_{T'}} \\
    R &amp;= \frac{1}{n} \sum_{T \in \mathcal{T}} \frac{A_{T \cap T'}}{A_T} \\
    C &amp;= \frac{|n-n'|}{n}
\end{align}
We try to quantitatively capture these characteristics by defining a set of indexes, which can be computed using the mosaic image and the corresponding ground truth:
\begin{itemize}
    \item $\mu_{A_T}$ and $\sigma_{A_T}$, the mean and standard deviation of the tiles area $A_T$, respectively;
    \item $\rho_\text{filler}$, the ratio between the filler area and the overall mosaic are, computed as $\rho_\text{filler}=\frac{\sum_{T \in \mathcal{T} A_T}}{A}$, being $A$ the area of the mosaic;
    \item \todo{does it worth?};
    \item \todo{does it worth?};
    \item $\mu_{C_T}$, the mean of the tiles \emph{color dispersion} $C_T$, being $C_T = \sigma_R+\sigma_G+\sigma_B$, where $\sigma_R$, $\sigma_G$ and $\sigma_B$ are the standard deviation of the red, green and blue channel values of the pixels within the tile $T$.
After applying a method to an image, we compare the segmented image (i.e., the result) against the ground truth and assess the performance according to the following three metrics:
\begin{itemize}
    \item average tile precision $P$
    \item average tile recall $R$
    \item tile count error $C$
\end{itemize}
Let $T$ be a tile on the ground truth $\mathcal{T}$ with area $A_T$.
Let $T'$ be the tile in the segmented image which mostly overlaps $T$ and let $A_{T'}$ be the area of $T$; let $A_{T \cap T'}$ be the overlapping area between $T$ and $T'$.
Let $n$ and $n'$ the number of tiles respectively in the ground truth and in the segmented image.
Metrics are defined as:
\begin{align}
    P &amp;= \frac{1}{n} \sum_{T \in \mathcal{T}} \frac{A_{T \cap T'}}{A_{T'}} \\
    R &amp;= \frac{1}{n} \sum_{T \in \mathcal{T}} \frac{A_{T \cap T'}}{A_T} \\
    C &amp;= \frac{|n-n'|}{n}
\end{align}
```

Δίνεται η απάντηση:
```python
['$\\mu_{A_T}$',
 '$\\sigma_{A_T}$',
 '$A_T$',
 '$\rho_\text{filler}$',
 '$\rho_\text{filler}=\x0crac{\\sum_{T \\in \\mathcal{T} A_T}}{A}$',
 '$A$',
 '$\\mu_{C_T}$',
 '$C_T$',
 '$C_T = \\sigma_R+\\sigma_G+\\sigma_B$',
 '$\\sigma_R$',
 '$\\sigma_G$',
 '$\\sigma_B$',
 '$T$',
 '$P$',
 '$R$',
 '$C$',
 '$T$',
 '$\\mathcal{T}$',
 '$A_T$',
 "$T'$",
 '$T$',
 "$A_{T'}$",
 '$T$',
 "$A_{T \\cap T'}$",
 '$T$',
 "$T'$",
 '$n$',
 "$n'$",
 '$\\mu_{A_T}$',
 '$\\sigma_{A_T}$',
 '$A_T$',
 '$\rho_\text{filler}$',
 '$\rho_\text{filler}=\x0crac{\\sum_{T \\in \\mathcal{T} A_T}}{A}$',
 '$A$',
 '$\\mu_{C_T}$',
 '$C_T$',
 '$C_T = \\sigma_R+\\sigma_G+\\sigma_B$',
 '$\\sigma_R$',
 '$\\sigma_G$',
 '$\\sigma_B$',
 '$T$',
 '$P$',
 '$R$',
 '$C$',
 '$T$',
 '$\\mathcal{T}$',
 '$A_T$',
 "$T'$",
 '$T$',
 "$A_{T'}$",
 '$T$',
 "$A_{T \\cap T'}$",
 '$T$',
 "$T'$",
 '$n$',
 "$n'$"]
```

### Άσκηση 6
Γράψτε ένα regular expression το οποίο θα αναγνωρίζει filenames από αρχεία εικόνας. Αρχεία εικόνας θεωρούμε αυτά που τελειώνουν σε .jpg .png και .gif. Επίσης θα πρέπει να εξάγει το όνομα του αρχείου (με τη group(1)) και τη κατάληξη του αρχείου (με group(2)).

Π.χ:
```
.bash_profile # Δεν κάνει match
workspace.doc # Δεν κάνει match
img0912.jpg # group(1)--> 'img0912', group(2) --> 'jpg'
updated_img0912.png # group(1)--> 'updated_img0912', group(2) --> 'png'
documentation.html # Δεν κάνει match
favicon.gif # group(1)--> 'favicon', group(2) --> 'gif'
img0912.jpg.tmp # Δεν κάνει match
```

## Μέρος 2ο, Κλάσεις

### Άσκηση 7
Γράξτε μία κλάση η οποία αναπαριστάει μία περιοχή στο ανθρώπινο γονιδίωμα. Μία περιοχή ορίζεται από το χρωμόσωμα, τη θέση του νουκλεοτιδίου που αρχίζει και τη θέση του νουκλεοτιδίου που τελείωνει. Θα πρέπει να μπορώ να γράψω:

```python
p = Position('chr5', start=10000, end=10001)
```

Θα πρέπει να ελέγχει ότι το χρωμόσωμα δεν μπορεί να πάρει άλλες τιμές εκτώς από chr1, chr2, ... chr22, X, Y ή ΜΤ (μιτοχονδριακό). 
Επίσης θα πρέπει να ελέγχει ότι το start και end δεν είναι έξω από τα όρια των μεγεθών των χρωμοσωμάτων. Αν υπάρχει κάποιο λάθος κάντε raise Exception..

```python
raise Exception('info about the error')
```

Δίνονται παρακάτω τα [μεγέθη των χρωμοσωμάτων σύμφωνα με την έκδοση hg19 του ανθρώπινου γωνιδιώματος](http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/hg19.chrom.sizes):

```python
sizes = {
        'chr1':    249250621,
        'chr2':    243199373,
        'chr3':    198022430,
        'chr4':    191154276,
        'chr5':    180915260,
        'chr6':    171115067,
        'chr7':    159138663,
        'chrX':    155270560,
        'chr8':    146364022,
        'chr9':    141213431,
        'chr10':   135534747,
        'chr11':   135006516,
        'chr12':   133851895,
        'chr13':   115169878,
        'chr14':   107349540,
        'chr15':   102531392,
        'chr16':   90354753,
        'chr17':   81195210,
        'chr18':   78077248,
        'chr20':   63025520,
        'chrY' :   59373566,
        'chr19':   59128983,
        'chr22':   51304566,
        'chr21':   48129895,
        'chrMT' :   16571,
    }
``` 

### Άσκηση 8
(συνεχίζουμε την άσκηση 7)

Προσθέστε τη static methdod, check_position η οποία θα παίρνει ένα χρωμόσωμα και μία νουκλεοτιδική θέση και θα επιστρέφει True/False ανάλογα με το αν η θέση υπάρχει. Θα πρέπει να μπορώ να γράφω:
```python
Position.check_size('chr22', 10000000) # True
Position.check_size('chr22', 60000000) # False
Position.check_size('Mitsos', 10000000) # False
Position.check_size('chr22', -100) # False
```

### Άσκηση 9
(συνεχίζουμε την άσκηση 8)
Προσθέστε τις μεθόδους __str__() και __len__(), η πρώτη θα τυπώνει το χρωμόσωμα, την αρχή και το τέλος της θέσης και η δεύτερη θα τυπώνει το ```end-start```. Θα πρέπει δηλαδή να μπορώ να γράφω:

```python
p = Position('chr5', start=10000, end=10010)
print (p) # Τυπώνει: `chr5, 10000-10010`
print (len(p)) # Τυπώνει 10
```

### Άσκηση 10
(συνεχίζουμε την άσκηση 9)
Φτιάξτε τη κλάση Mutation η οποία θα κάνει κληρονομεί τη κλάση Position. Η αρχικοποίηση στη Mutation θα έχει δύο επιπλέον παραμέτρους: reference και alternative. 
Τα reference και alternative θα είναι ακολουθίες DNA (δηλαδή μόνο γράμματα ACGT).

Θα πρέπει αν ελέγχει ότι:
* Τα reference και alternative έχουν μόνο χαρακτήρες ACGT, διαφορετικά θα πετάει exception.
* To reference δεν μπορεί να είναι το ίδιο με το alternative, διαφορετικά θα πετάει exception.
<!-- * Το μήκος του reference είναι τόσο όσο και το μήκος (len()) του Position, διαφορετικά θα πετάει exception -->

Επίσης θα έχει τη μέθοδο: type η οποία:
* Αν το reference έχει μήκος 1 και το alternative έχει μήκος 1 θα επιστρέφει [SNP](https://en.wikipedia.org/wiki/Single-nucleotide_polymorphism)
* Αν το reference έχει μέγεθος ίσο με το alternative αλλά και τα δύο είναι διαφορετικά από 1 θα επιστρέφει: "substitution"
* Αν το reference έχει μέγεθος 0 και το alternative έχει μέγεθος>0 τότε θα επιστρέφει: "insertion"
* Αν το reference έχει μέγεθος>0 και το alternative έχει μέγεθος 0 τότε θα επιστρέφει: "deletion"
* Διαφορετικά επιστρέφει: "complex mutation" 

Επίσης θα πρέπει να έχει τη δική της __str__ μέθοδο η οποία θα τυπώνει κάτι σαν: ```chr5 10000-100001 A>C```


```python
m = Mutation('chr5', start=10000, end=10001, reference='A', alternative='C')
m.type() # Επιστρέφει 'SNP'

m = Mutation('chr5', start=10000, end=10001, reference='', alternative='C')
m.type() # Επιστρέφει 'insertion'

print (m) # chr5 10000-10001 >C

```

### Άσκηση 11
(συνεχίζουμε την άσκηση 10)

Φτιάξτε τη μέθοδο serialize() στη κλάση Mutation οποία επιστρέφει ένα dictionary με όλα τα στοιχεία της κλασης. Θα πρέπει δηλαδή να μπορώ να γράφω:

```python
m = Mutation('chr5', start=10000, end=10001, reference='A', alternative='C')

m.serialize() 

# Επιστρέφει το dictionary
{
	'chromosome': 'chr5',
	'start': 10000,
	'end': 10001,
	'reference': 'A',
	'alternative': 'C',
}
```

Στη συνέχεια θα πρέπει να μπορείτε να κάνετε:

```python
new_mutation = Mutation(**m.serialize())
```

Και το new_mutation να έχει τα ίδια στοιχεία με το m

### Άσκηση 12
Αν θεωρήσουμε ότι έχετε υλοποιήσει την άσκηση 10, τότε ο παρακάτω κώδικας φτιάχνει ένα τυχαίο mutation

```python
import random

def random_mutation():
	# Creates only SNPs
	random_chromosome = random.choice(sizes.keys())
	random_start = random.randint(1, sizes[random_chromosome]-1)
	random_end = random_start+1
	random_reference = random.choice('ACGT')
	random_alternative = random.choice('ACGT'.replace(random_reference, ''))
	return Mutation(
		chromosome=random_chromosome,
		start=random_start,
		end=random_end,
		reference=random_reference,
		alternative=random_alternative,
	)


```

Σε αυτή την άσκηση θα πρέπει απλά να επιβεβαιώσετε ότι ο παρακάτω κώδικας τρέχει (δεν πρέπει να κάνετε τίποτα άλλο!):

```python
# Φτιάχνω 1000 random mutations.
mutations = [random_mutation() for x in range(1000)]

# Τα κάνω serialize
mutations_serialized = [x.serialize() for x in mutations]

# Τα αποθηκεύω σε ένα αρχείο:
import json
with open('mutations.json', 'w') as f:
	json.dump(mutations_serialized, f)

# Τα φορτώνω από το αρχείο:
with open('mutations.json') as f:
	mutations_serialized_2 = json.load(f)

# δημιουργώ τις κλάσεις
mutations_2 = [Mutation(**x) for x in mutations_serialized_2]
```

## Μέρος 3ο. Numpy 
Οι παρακάτω ασκήσεις πρέπει να υλοποιηθούν με numpy.

### Άσκηση 13
Ο παρακάτω πίνακας έχει 10 γραμμές και 6 στήλες
```python
a = np.array([[8.017, 65.088, 87.134, 30.050, 58.340, 40.148],
       [67.919, 43.463, 79.004, 91.098, 22.282, 92.925],
       [35.850, 8.067, 55.315, 35.333, 84.915, 42.682],
       [90.585, 91.515, 39.380, 8.990, 58.726, 23.867],
       [56.745, 96.424, 50.007, 46.955, 72.845, 18.849],
       [16.405, 38.923, 22.694, 96.561, 32.377, 77.826],
       [42.870, 96.114, 89.887, 39.800, 68.252, 70.092],
       [52.975, 40.269, 74.661, 54.489, 5.173, 98.359],
       [75.736, 38.505, 87.102, 45.873, 38.369, 81.094],
       [22.243, 3.135, 0.230, 39.588, 28.393, 62.661]])
```

Αναπαριστάει την έκφραση 10 διαφορετικών γονιδίων σε 6 διαφορετικές χρονικές στιγμές.

Μετρήσαμε επίσης την έκφραση ενός άλλου γονιδίου στις ίδιες 6 διαφορετικές στιγμές:
```python
b = np.array([37.206, 43.282, 72.423, 85.898, 8.480, 9.290])
```

Ποιο από τα 10 γονίδια του a έχει τη μικρότερη ευκλίδεια απόσταση με το b;

### Άσκηση 14
Φτιάξτε μία συνάρτηση η οποία θα δέχεται μία παράμετρο ν. Η συνάρτηση θα πρέπει να επιστρέφει έναν πίνακα όπως φαίνεται από τα παρακάτω παραδείγματα:

```text
ν=1
1

ν=2
2 2 2
2 1 2 
2 2 2

ν=3
3 3 3 3 3 
3 2 2 2 3
3 2 1 2 3
3 2 2 2 3
3 3 3 3 3

κτλ..
```

### Άσκηση 15

Ο παρακάτω κώδικας κατεβάζει και φορτώνει τα δεδομένα από το [iris dataset](https://en.wikipedia.org/wiki/Iris_flower_data_set) 


```python
import numpy as np

url = 'https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data'
iris = np.genfromtxt(url, delimiter=',', dtype='object')
sepal_length = np.array([float(row[0]) for row in iris])
sepal_width = np.array([float(row[1]) for row in iris])
petal_length = np.array([float(row[2]) for row in iris])
petal_width = np.array([float(row[3]) for row in iris])
flower = [{b'Iris-setosa': 0, b'Iris-versicolor': 1, b'Iris-virginica': 2}[row[4]] for row in iris]
```

Το dataset περιέχει το sepal_length, sepal_width, petal_length και petal_width για 150 λουλούδια τα οποία ανήκουν σε 3 διαφορετικά είδη.
To flower είναι ένας πίνακας ο οποίος περιέχει 0,1 ή 2 ανάλογα με το είδος του λουλουδιού. 

Απαντήστε στα ερωτήματα:
* Σε ποιο λουλούδι ανήκει το μεγαλύτερο sepal_width;

### Άσκηση 16
* Ποιος είναι ο μέσος όρος του petal_width ανά διαφορετικό είδος λουλουδιού (δλδ θέλουμε 3 νούμερα);

### Άσκηση 17
* Πόσα Iris-setosa, πόσα Iris-versicolor και πόσα Iris-virginica λουλούδια υπάρχουν που το petal_length είναι μεγαλύτερα από το sepal_width;

### Άσκηση 18
Ας υποθέσουμε ότι πετάμε 100,000 βελάκια σε μία επιφάνεια 1 χ 1 μέτρο. Υποθέτουμε ότι είμαστε.. άμπαλοι και ότι ένα βελάκι μπορεί να πάει σε οποιοδίποτε σημείο της επιφάνειας με ίδια πιθανότητα. Ποιο είναι το ποσοστό των βελακίων τα οποία έχουν απόσταση μικρότερη ή ίση με 1 μέτρο από το κέντρο της επιφάνειας;

Πόσο κάνει αυτό το ποσοστό αν το πολλαπλασιάσουμε επί 4;

### Άσκηση 19 + 20 (μετράει για δύο ασκήσεις)

Δίνεται η παρακάτω συνάρτηση:

```python
import hashlib 
def unique_8x8(s):
      
    result = hashlib.md5(s.encode()) 
    h = result.hexdigest()[-16:]
    l = ['{a:0>8b}'.format(a=bytearray.fromhex(h[i:i+2])[0]) for i in range(0, len(h), 2)]
    
    k = np.array([[int(y) for y in x] for x in l])
    return k
```

Αυτή η συνάρτηση παίρνει ένα string και επιστρέφει έναν numpy array 8x8 μοναδικό για αυτό το string ο οποίος αποτελείται από 0 και 1. Για παράδειγμα:

```python
unique_8x8('mitsos')

array([[1, 1, 1, 1, 1, 0, 0, 1],
       [0, 1, 1, 1, 1, 1, 1, 1],
       [0, 1, 1, 0, 0, 0, 0, 1],
       [1, 0, 1, 0, 1, 1, 1, 1],
       [1, 1, 0, 0, 1, 0, 0, 1],
       [1, 0, 0, 1, 1, 0, 1, 0],
       [1, 0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 1, 1, 0, 0]])
```

Ας φανταστούμε ότι έχουμε ένα τετραγωνικό κομμάτι χαρτί (το πλάτος είναι ίδιο με το μήκος). Στο χαρτί ζωγραφίζουμε ένα grid 256 Χ 256. Χωρίζουμε την επιφάνεια δηλαδή σε 256 Χ 256 μικρά τετραγωνάκια. 

Τώρα διπλώνουμε το χαρτί στα δύο, φέρνοντας την αριστερή πλευρά του πάνω στη δεξιά. Τώρα το grid έγινε 256 Χ 128

Τώρα διπλώνουμε το χαρτί στα δύο ξανά φέρνοντας την πάνω πλευρά του πάνω στη κάτω. Τώρα το grid έγινε 128 Χ 128

Αν επαναλάβουμε τις παραπάνω δύο ενέργειες, τότε το grid θα γίνει 64 Χ 64

Αν το επαναλάβουμε ακόμα μία φορά το grid θα γίνει 32 Χ 32

Αν το επαναλάβουμε ακόμα μία φορά το grid θα γίνει 16 Χ 16

Τέλος, αν το επαναλάβουμε μία τελευταία φορά θα γίνει 8 Χ 8

Στη συνέχεια χρησιμοποιήστε τη συνάρτηση unique_8x8 με το όνομά σας για να φτιάξετε έναν μοναδικό για εσάς 8 Χ 8 πίνακα.

Τώρα στο 8 Χ 8 grid που έχει μείνει στο διπλωμένο χαρτί, αντιγράφουμε τον πίνακα αυτό.

Με ένα ψαλίδι αφαιρούμε τα τετραγωνάκια που έχουν 0. Τα τετραγωνάκια που έχουν 1 τα αφήνουμε. 

Ξεδιπλώστε τη σελίδα ώστε να πάρει τα αρχικό της μέγεθος (256 Χ 256)

Αν τα τετραγωνάκια που τρυπήσαμε τα αναπαραστήσουμε με μαύρο και αυτά που δεν τρυπήσαμε τα αναπαραστήσουμε με άσπρο, πως θα φαίνεται η σελίδα σας;

Χρησιμοποιήστε τη ```plt.imshow(a)``` για να δείξετε τον τελικό πίνακα που περιέχει τη σελίδα σας. 

Hint: https://docs.scipy.org/doc/numpy/reference/generated/numpy.flip.html 

Για το φανταστικό όνομά μου (Αλέξανδρος Καντεράκης), αυτό που παρήγαγε αυτή η μέθοδος είναι (εδώ έχω χρησιμοποιείσει το default colormap, για να το δείξετε άσπρο μαύρο κάντε: ```plt.imshow(a, cmap='gray')``` ):

![img](alex.png)



